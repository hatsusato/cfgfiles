#!/bin/bash

emulate-complete() {
  local cur prev words cword
  _init_completion || return
  set -- $(complete -p $words)
  [[ $1 == complete ]] || return
  [[ ${@: -1} == $words ]] || return
  shift
  local opts=()
  while ((1 < $#)); do
    case $1 in
      -[abcdefgjksuv])
        opts+=($1)
        shift;;
      -o)
        compopt -o $2 >/dev/null
        shift 2;;
      -F)
        $2 $words $cur $prev
        return $?;;
      -[AGWCXPS])
        opts+=($1 $2)
        shift 2;;
      *)
        echo ERROR: invalid complete: $(complete -p $words) >&2
        return 1;;
    esac
  done
  COMPREPLY=($(compgen ${opts[@]} -- $cur))
}

parse-split-words() {
  local i c w=
  for ((i=0; i<${#1}; ++i)); do
    c=${1:$i:1}
    case $c in
      [$COMP_WORDBREAKS]) list+=("$w" "$c"); w=;;
      *) w+=$c;;
    esac
  done
  list+=("$w")
}
parse-quote-words() {
  local e w= q=
  list=()
  for e in "$@"; do
    if [[ -n $q ]]; then
      w+=$e
      [[ $q == $e ]] && q=
      continue
    fi
    case $e in
      [$IFS])
        if [[ -n "$w" ]]; then
          list+=("$w")
          w=
        fi;;
      [\'\"]) q=$e; w+=$e;;
      [\|\&]) list=(); w=;;
      *) w+=$e;;
    esac
  done
  [[ -n "$w" ]] && list+=("$w")
}
replace-command() {
  local list=()
  parse-split-words "$1"
  parse-quote-words "${list[@]}"
  local line=${list[@]}
  COMP_LINE=${COMP_LINE/#$COMP_WORDS/$line}
  ((COMP_POINT += ${#line} - ${#COMP_WORDS}))
  ((COMP_CWORD += ${#list[@]} - 1))
  COMP_WORDS=("${list[@]}" "${COMP_WORDS[@]:1}")
}

exist-alias() {
  [[ -n $@ && -n ${BASH_ALIASES[$@]+x} ]]
}

alias-complete() {
  exist-alias $COMP_WORDS || return
  replace-command "${BASH_ALIASES[$COMP_WORDS]}"
  local comp=$(complete -p $COMP_WORDS 2>/dev/null)
  if [[ -z $comp ]]; then
    _completion_loader $COMP_WORDS
  elif [[ $comp == *+( )-F+( )alias-complete?( *) ]]; then
    complete -F _minimal -- $COMP_WORDS && return 124
  else
    emulate-complete
  fi
}

auto-completion-loader() {
  __load_completion "$1" && return 124
  if exist-alias "$1"; then
    complete -F alias-complete -- "$1" && return 124
  fi
  complete -F _minimal -- "$1" && return 124
} && complete -D -F auto-completion-loader

debug-complete() {
  local comp log=${DEBUG+/tmp/$USER/debug.log}
  for comp in words point line cword; do
    declare -p COMP_${comp^^}
  done >>${log:-/dev/null}
  echo >>${log:-/dev/null}
}
