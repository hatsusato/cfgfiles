#!/bin/bash

parse-quote-words() {
  COMP_WORDS=()
  local list=() arg i c q=
  for arg in "$@"; do
    list+=("$arg")
    if [[ $q == *@(\'|\")* ]]; then
      for ((i=0; i<${#arg}; ++i)); do
        c=${arg:i:1}
        [[ $c == @(\'|\") ]] || continue
        [[ -z $q || $c == $q ]] || continue
        q=${c#$q}
      done
    fi
    [[ -z $q ]] || continue
    COMP_WORDS+=("${list[*]}")
    list=()
  done
  [[ -z $q ]] || COMP_WORDS+=("${list[*]}")
}
replace-command() {
  local words=("${COMP_WORDS[@]}")
  parse-quote-words "$@"
  COMP_LINE=${COMP_WORDS[@]}
  ((COMP_POINT += ${#COMP_LINE} - ${#words}))
  COMP_WORDS+=("${words[@]:1}")
  COMP_LINE=${COMP_WORDS[@]}
  COMP_CWORD=${#COMP_WORDS[@]}
}

emulate-complete() {
  local cur prev words cword cmd
  _init_completion || return
  cmd=$words
  set -- $(complete -p "$cmd")
  # assert: [[ $1 == complete ]]
  # assert: [[ ${@: -1} == $cmd ]]
  shift
  local opts=()
  while ((1 < $#)); do
    case $1 in
      -[abcdefgjksuv])
        opts+=($1)
        shift;;
      -o)
        compopt -o "$2" >/dev/null
        shift 2;;
      -F)
        eval "$2" "$cmd" "$cur" "$prev"
        return $?;;
      -[AGWCXPS])
        eval opts+=($1 "$2")
        shift 2;;
      *)
        echo "ERROR: invalid complete: "$(complete -p "$cmd") >&2
        return 1;;
    esac
  done
  COMPREPLY=($(compgen "${opts[@]}" -- "$cur"))
}

exist-alias() {
  [[ -n $@ && -n ${BASH_ALIASES[$@]+x} ]]
}

alias-complete() {
  exist-alias $COMP_WORDS || return
  replace-command ${BASH_ALIASES[$COMP_WORDS]}
  local comp=$(complete -p $COMP_WORDS 2>/dev/null)
  if [[ -z $comp ]]; then
    _completion_loader $COMP_WORDS
  elif [[ $comp == *+( )-F+( )alias-complete?( *) ]]; then
    complete -F _minimal -- $COMP_WORDS && return 124
  else
    emulate-complete
  fi
}

auto-completion-loader() {
  __load_completion "$1" && return 124
  if exist-alias "$1"; then
    complete -F alias-complete -- "$1" && return 124
  fi
  complete -F _minimal -- "$1" && return 124
} && complete -D -F auto-completion-loader
